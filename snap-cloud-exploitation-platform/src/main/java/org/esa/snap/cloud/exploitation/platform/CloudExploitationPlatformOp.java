package org.esa.snap.cloud.exploitation.platform;

import com.bc.ceres.binding.converters.BooleanConverter;
import com.bc.ceres.binding.converters.IntegerConverter;
import com.bc.ceres.binding.converters.StringConverter;
import com.bc.ceres.binding.dom.DomElement;
import com.bc.ceres.core.PrintWriterConciseProgressMonitor;
import com.bc.ceres.core.ProgressMonitor;
import com.jcraft.jsch.JSchException;
import com.thoughtworks.xstream.io.copy.HierarchicalStreamCopier;
import com.thoughtworks.xstream.io.xml.XppDomWriter;
import com.thoughtworks.xstream.io.xml.XppReader;
import com.thoughtworks.xstream.io.xml.xppdom.XppDom;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;
import org.esa.snap.cloud.exploitation.platform.executors.OutputConsoleBuffer;
import org.esa.snap.cloud.exploitation.platform.executors.ProcessExecutor;
import org.esa.snap.cloud.exploitation.platform.executors.SSHConnection;
import org.esa.snap.cloud.exploitation.platform.utils.NamedThreadPoolExecutor;
import org.esa.snap.core.datamodel.Band;
import org.esa.snap.core.datamodel.Product;
import org.esa.snap.core.datamodel.ProductData;
import org.esa.snap.core.gpf.Operator;
import org.esa.snap.core.gpf.OperatorException;
import org.esa.snap.core.gpf.OperatorSpi;
import org.esa.snap.core.gpf.annotations.OperatorMetadata;
import org.esa.snap.core.gpf.annotations.Parameter;
import org.esa.snap.core.gpf.annotations.TargetProduct;
import org.esa.snap.core.gpf.common.ReadOp;
import org.esa.snap.core.gpf.common.WriteOp;
import org.esa.snap.core.gpf.graph.Graph;
import org.esa.snap.core.gpf.graph.GraphProcessor;
import org.esa.snap.core.gpf.graph.Node;
import org.esa.snap.engine_utilities.util.FileIOUtils;
import org.xmlpull.mxp1.MXParser;

import java.io.IOException;
import java.io.StringReader;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.spi.FileSystemProvider;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * Created by jcoravu on 27/12/2018.
 */
@OperatorMetadata(
        alias = "CloudExploitationPlatformOp",
        version="1.0",
        category = "Menu/Raster",
        autoWriteDisabled = true,
        description = "Execute the products on the remote machines.",
        authors = "Jean Coravu",
        copyright = "Copyright (C) 2018 by CS ROMANIA")
public class CloudExploitationPlatformOp extends Operator {

    private static final Logger logger = Logger.getLogger(CloudExploitationPlatformOp.class.getName());

    @Parameter(itemAlias = "sharedFolderURL", notNull = true, converter = StringConverter.class, description = "Specifies the shared folder URL.")
    private String masterSharedFolderURL;

    @Parameter(itemAlias = "username", notNull = true, converter = StringConverter.class, description = "Specifies the username account of the machine where the shared folder is created.")
    private String masterSharedFolderUsername;

    @Parameter(itemAlias = "password", notNull = true, converter = StringConverter.class, description = "Specifies the password account of the machine where the shared folder is created.")
    private String masterSharedFolderPassword;

    @Parameter(itemAlias = "localSharedFolderPath", notNull = true, converter = StringConverter.class, description = "Specifies the local shared folder path.")
    private String localSharedFolderPath;

    @Parameter(itemAlias = "localPassword", notNull = false, converter = StringConverter.class, description = "Specifies the password of the local machine.")
    private String localPassword;

    @Parameter(itemAlias = "slaveGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the slave graph file path to be executed on the remote machines.")
    private String slaveGraphFilePath;

    @Parameter(itemAlias = "sourceFiles", notNull = true, converter = SourceProductFilesConverter.class, description = "Specifies the product files.")
    private String[] sourceProductFiles;

    @Parameter(itemAlias = "machines", notNull = true, converter = RemoteMachineCredentialsConverter.class, description = "Specifies the remote machines credentials.")
    private RemoteMachineCredentials[] remoteMachines;

    @Parameter(itemAlias = "masterGraphFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the master graph file path.")
    private String masterGraphFilePath;

    @Parameter(itemAlias = "continueOnFailure", notNull = true, converter = BooleanConverter.class, description = "Specifies the flag to continue or not when a remote machine fails.")
    private Boolean continueOnFailure;

    @Parameter(itemAlias = "targetProductFormatName", notNull = true, converter = StringConverter.class, description = "Specifies the target product format name.")
    private String targetProductFormatName;

    @Parameter(itemAlias = "targetProductFilePath", notNull = true, converter = StringConverter.class, description = "Specifies the target product file path.")
    private String targetProductFilePath;

    @Parameter(itemAlias = "waitingSecondsTimeout", notNull = false, converter = IntegerConverter.class, description = "Specifies the waiting seconds to complete the output products on the remote machines.")
    private int waitingSecondsTimeout;

    @TargetProduct
    private Product targetProduct;

    public CloudExploitationPlatformOp() {
        this.waitingSecondsTimeout = 0;
    }

    @Override
    public void initialize() throws OperatorException {
        if (StringUtils.isBlank(this.masterSharedFolderURL)) {
            throw new OperatorInitializeException("The master shared folder URL is not specified.");
        }
        if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) {
            String normalizedMasterSharedFolderURL = CloudExploitationPlatformOp.normalizeUnixPath(this.masterSharedFolderURL);
            if (!normalizedMasterSharedFolderURL.startsWith("//")) {
                throw new OperatorInitializeException("The master shared folder URL '"+this.masterSharedFolderURL+"' does not specifies a shared folder.");
            }
        } else if (SystemUtils.IS_OS_WINDOWS) {
            String normalizedMasterSharedFolderURL = CloudExploitationPlatformOp.normalizeWindowsPath(this.masterSharedFolderURL);
            if (!normalizedMasterSharedFolderURL.startsWith("\\\\")) {
                throw new OperatorInitializeException("The master shared folder URL '"+this.masterSharedFolderURL+"' does not specifies a shared folder.");
            }
        }
        if (StringUtils.isBlank(this.masterSharedFolderUsername)) {
            throw new OperatorInitializeException("The username of the machine containing the shared folder URL is not specified.");
        }
        if (StringUtils.isBlank(this.masterSharedFolderPassword)) {
            throw new OperatorInitializeException("The password of the machine containing the shared folder URL is not specified.");
        }
        if (this.remoteMachines == null || this.remoteMachines.length == 0) {
            throw new OperatorInitializeException("The remote machines are not specified.");
        }
        if (StringUtils.isBlank(this.slaveGraphFilePath)) {
            throw new OperatorInitializeException("The slave graph file path is not specified.");
        }
        if (this.continueOnFailure == null) {
            throw new OperatorInitializeException("The flag to continue or not when a remote machine fails is not specified.");
        }
        if (this.sourceProductFiles == null || this.sourceProductFiles.length == 0) {
            throw new OperatorInitializeException("The source product files are not specified.");
        }
        if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) {
            if (StringUtils.isBlank(this.localSharedFolderPath)) {
                throw new OperatorInitializeException("The local shared folder path must be specified when running on Unix operating systems.");
            }
            Path path;
            try {
                String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeUnixPath(this.localSharedFolderPath);
                path = buildPath(normalizedLocalSharedFolderPath);
            } catch (URISyntaxException exception) {
                throw new OperatorInitializeException("The local shared folder path '"+this.localSharedFolderPath+"' is incorrect.", exception);
            }
            if (!path.isAbsolute()) {
                throw new OperatorInitializeException("The local shared folder path '"+this.localSharedFolderPath+"' does not represent an absolute path on Unix operating systems.");
            }
            if (SystemUtils.IS_OS_LINUX) {
                if (StringUtils.isBlank(this.localPassword)) {
                    throw new OperatorInitializeException("The local password must be specified when running on Linux.");
                }
            }
        } else if (SystemUtils.IS_OS_WINDOWS) {
            if (!StringUtils.isBlank(this.localSharedFolderPath)) {
                char driveLetter = this.localSharedFolderPath.charAt(0);
                if (!Character.isLetter(driveLetter)) {
                    throw new IllegalArgumentException("The local shared folder path does not represent a drive when running on Windows The first character '"+driveLetter+"' is not a letter.");
                }
                String colon = this.localSharedFolderPath.substring(1);
                if (!":".equals(colon)) {
                    throw new IllegalArgumentException("Expected 'X:' for local shared driver when running on Windows.");
                }
            }
        }
        if (canCreateTargetProduct()) {
            if (StringUtils.isBlank(this.masterGraphFilePath)) {
                throw new OperatorInitializeException("The master graph file path is not specified.");
            }
            if (StringUtils.isBlank(this.targetProductFilePath)) {
                throw new OperatorInitializeException("The target product file path is not specified.");
            }
            if (StringUtils.isBlank(this.targetProductFormatName)) {
                throw new OperatorInitializeException("The target forrmat name is not specified.");
            }
        }

        // create a dummy target product required by the operator context
        int sceneRasterWidth = 1;
        int sceneRasterHeight = 1;
        this.targetProduct = new Product("CloudExploitationPlatform", "test", sceneRasterWidth, sceneRasterHeight);
        Band targetBand = new Band("band_1", ProductData.TYPE_INT32, sceneRasterWidth, sceneRasterHeight);
        this.targetProduct.addBand(targetBand);
    }

    @Override
    public void doExecute(ProgressMonitor pm) throws OperatorException {
        try {
            // mount the local shared folder
            UnixMountLocalFolderResult unixMountLocalFolderResult = null;
            ILocalMachineFileSystem localMachineFileSystem;
            String localMachineSharedFolderPath;
            if (SystemUtils.IS_OS_LINUX) {
                unixMountLocalFolderResult = mountLinuxLocalFolder(this.masterSharedFolderURL, this.masterSharedFolderUsername,
                                                                this.masterSharedFolderPassword, this.localSharedFolderPath, this.localPassword);
                if (!unixMountLocalFolderResult.isSharedFolderMounted()) {
                    throw new OperatorException("Failed to mount the local shared folder '" + this.localSharedFolderPath + "' to the remote shared folder '" + this.masterSharedFolderURL + "'.");
                }
                // the local shared folder has been successfully mounted
                localMachineFileSystem = new UnixLocalMachineFileSystem();
                localMachineSharedFolderPath = this.localSharedFolderPath;
            } else if (SystemUtils.IS_OS_WINDOWS) {
                localMachineFileSystem = new WindowsLocalMachineFileSystem();
                if (StringUtils.isBlank(this.localSharedFolderPath)) {
                    // no local shared drive to mount on Windows
                    localMachineSharedFolderPath = this.masterSharedFolderURL;
                } else {
                    boolean mounted = mountWindowsLocalDrive(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, this.localSharedFolderPath);
                    if (!mounted) {
                        throw new OperatorException("Failed to mount the local drive '" + this.localSharedFolderPath + "' to the remote shared folder '" + this.masterSharedFolderURL + "'.");
                    }
                    // the local shared folder has been successfully mounted
                    localMachineSharedFolderPath = this.localSharedFolderPath;
                }
            } else if (SystemUtils.IS_OS_MAC) {
                unixMountLocalFolderResult = mountMacLocalFolder(this.masterSharedFolderURL, this.masterSharedFolderUsername,
                                                                    this.masterSharedFolderPassword, this.localSharedFolderPath);
                if (!unixMountLocalFolderResult.isSharedFolderMounted()) {
                    throw new OperatorException("Failed to mount the local shared folder '" + this.localSharedFolderPath + "' to the remote shared folder '" + this.masterSharedFolderURL + "'.");
                }
                // the local shared folder has been successfully mounted
                localMachineFileSystem = new UnixLocalMachineFileSystem();
                localMachineSharedFolderPath = this.localSharedFolderPath;
            } else {
                throw new UnsupportedOperationException("Unsupported operating system '" + SystemUtils.OS_NAME + "'.");
            }
            try {
                String normalizedMasterSharedFolderURL = localMachineFileSystem.normalizeFileSeparator(this.masterSharedFolderURL + "/");
                String normalizedLocalSharedFolderPath = localMachineFileSystem.normalizeFileSeparator(localMachineSharedFolderPath + "/");

                Path localSharedFolder = buildPath(normalizedLocalSharedFolderPath);

                String[] relativeSourceProductFilePaths = new String[this.sourceProductFiles.length];
                for (int i = 0; i < this.sourceProductFiles.length; i++) {
                    String normalizedSourceProductFilePath = localMachineFileSystem.normalizeFileSeparator(this.sourceProductFiles[i]);
                    String relativePath;
                    if (localMachineFileSystem.pathStartsWith(normalizedSourceProductFilePath, normalizedMasterSharedFolderURL)) {
                        relativePath = normalizedSourceProductFilePath.substring(normalizedMasterSharedFolderURL.length());
                    } else if (localMachineFileSystem.pathStartsWith(normalizedSourceProductFilePath, normalizedLocalSharedFolderPath)) {
                        relativePath = normalizedSourceProductFilePath.substring(normalizedLocalSharedFolderPath.length());
                    } else {
                        StringBuilder errorMessage = new StringBuilder();
                        errorMessage.append("The source product file '")
                                .append(normalizedSourceProductFilePath)
                                .append("' does not start with the master shared folder '")
                                .append(normalizedMasterSharedFolderURL);
                        if (!normalizedMasterSharedFolderURL.equalsIgnoreCase(normalizedLocalSharedFolderPath)) {
                            errorMessage.append("' neither the local shared folder '")
                                        .append(normalizedLocalSharedFolderPath);
                        }
                        errorMessage.append("'.");
                        throw new OperatorException(errorMessage.toString());
                    }
                    Path sourceFilePath = localSharedFolder.resolve(relativePath);
                    if (Files.exists(sourceFilePath)) {
                        relativeSourceProductFilePaths[i] = relativePath;
                    } else {
                        throw new OperatorException("The source product file '" + normalizedSourceProductFilePath + "' does not exist into the master shared folder.");
                    }
                }

                Path slaveGraphFile = checkGraphFileIfExists(localMachineFileSystem, normalizedMasterSharedFolderURL, localSharedFolder, this.slaveGraphFilePath, false);
                Path masterGraphFile = null;
                if (canCreateTargetProduct()) {
                    masterGraphFile = checkGraphFileIfExists(localMachineFileSystem, normalizedMasterSharedFolderURL, localSharedFolder, this.masterGraphFilePath, true);
                }

                writeGraphsToSharedFolder(localMachineFileSystem, localSharedFolder, relativeSourceProductFilePaths, slaveGraphFile, masterGraphFile);
            } finally {
                // unmount the local shared folder
                if (SystemUtils.IS_OS_LINUX) {
                    unmountLinuxLocalFolder(this.localSharedFolderPath, this.localPassword, unixMountLocalFolderResult);
                } else if (SystemUtils.IS_OS_WINDOWS) {
                    if (!StringUtils.isBlank(this.localSharedFolderPath)) {
                        unmountWindowsLocalDrive(this.localSharedFolderPath);
                    }
                } else if (SystemUtils.IS_OS_MAC) {
                    unmountMacLocalFolder(this.localSharedFolderPath, unixMountLocalFolderResult);
                }
            }
        } catch (OperatorException exception) {
            throw exception;
        } catch (Exception exception) {
            throw new OperatorException("Failed to execute the operator.", exception);
        }
    }

    public boolean canCreateTargetProduct() {
        if (StringUtils.isBlank(this.masterGraphFilePath) && StringUtils.isBlank(this.targetProductFilePath) && StringUtils.isBlank(this.targetProductFormatName)) {
            return false;
        }
        return true;
    }

    private AbstractRemoteMachineExecutor buildRemoteMachineExecutor(RemoteMachineCredentials remoteMachineCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper) {
        if (remoteMachineCredentials.isLinux()) {
            return new LinuxRemoteMachineExecutor(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, remoteMachineCredentials, remoteMachinesGraphHelper);
        } else if (remoteMachineCredentials.isWindows()) {
            return new WindowsRemoteMachineExecutor(this.masterSharedFolderURL, this.masterSharedFolderUsername, this.masterSharedFolderPassword, remoteMachineCredentials, remoteMachinesGraphHelper);
        } else {
            throw new IllegalArgumentException("The remote machine operating system is unknown '"+ remoteMachineCredentials.getOperatingSystemName()+"'.");
        }
    }

    private void writeGraphsToSharedFolder(ILocalMachineFileSystem localMachineFileSystem, Path localSharedFolder, String[] relativeSourceProductFilePaths,
                                           Path slaveGraphFile, Path masterGraphFile)
                                           throws Exception {

        Path localOutputFolder = localSharedFolder.resolve("cloud-exploitation-platform");

        if (Files.exists(localOutputFolder)) {
            // delete the folder
            FileIOUtils.deleteFolder(localOutputFolder);
            // check if the folder still exists
            if (Files.exists(localOutputFolder)) {
                throw new IllegalStateException("Failed to delete the output folder path '" + localOutputFolder.toString()+ "' from the local shared folder.");
            }
        }
        Files.createDirectory(localOutputFolder);
        if (!Files.exists(localOutputFolder)) {
            throw new IllegalStateException("Failed to create the output folder path '" + localOutputFolder.toString()+ "' into the local shared folder.");
        }

        RemoteMachinesGraphHelper remoteMachinesGraphHelper = new RemoteMachinesGraphHelper(localMachineFileSystem, localOutputFolder, relativeSourceProductFilePaths, slaveGraphFile,
                                                                                            this.continueOnFailure.booleanValue());

        CountDownLatch sharedCounter = new CountDownLatch(this.remoteMachines.length);
        RemoteMachineGraphExecutorRunnable[] remoteMachineRunnables = new RemoteMachineGraphExecutorRunnable[this.remoteMachines.length];
        for (int i = 0; i < this.remoteMachines.length; i++) {
            remoteMachineRunnables[i] = buildRemoteMachineGraphExecutorRunnable(this.remoteMachines[i], remoteMachinesGraphHelper, sharedCounter);
        }

        int processorCount = Runtime.getRuntime().availableProcessors();
        ThreadPoolExecutor threadPoolExecutor = null;
        boolean remoteOutputProductsCreated = false;
        try {
            if (this.waitingSecondsTimeout > 0) {
                threadPoolExecutor = new NamedThreadPoolExecutor("cep", processorCount);
                for (int i = 0; i < remoteMachineRunnables.length; i++) {
                    threadPoolExecutor.execute(remoteMachineRunnables[i]); // start the thread
                }
                boolean countHasReachedZero = sharedCounter.await(this.waitingSecondsTimeout, TimeUnit.SECONDS);
                if (countHasReachedZero) {
                    remoteOutputProductsCreated = true;
                } else {
                    // stop the running commands
                    for (int i = 0; i < remoteMachineRunnables.length; i++) {
                        remoteMachineRunnables[i].stopRunningCommand();
                    }
                    sharedCounter.await();
                }
            } else {
                if (remoteMachineRunnables.length > 1) {
                    threadPoolExecutor = new NamedThreadPoolExecutor("cep", processorCount);
                    for (int i = 1; i < remoteMachineRunnables.length; i++) {
                        threadPoolExecutor.execute(remoteMachineRunnables[i]); // start the thread
                    }
                }
                remoteMachineRunnables[0].run(); // run on the current thread
                sharedCounter.await();
                remoteOutputProductsCreated = true;
            }
        } finally {
            if (threadPoolExecutor != null) {
                threadPoolExecutor.shutdown();
            }
        }

        if (remoteOutputProductsCreated) {
            boolean canCreateTargetProduct = (masterGraphFile != null);
            if (remoteMachinesGraphHelper.canContinueIfExceptionOccurredOnRemoteMachines()) {
                // no exception occurred on the remote machines
                if (canCreateTargetProduct) {
                    logger.log(Level.FINE, "Create the target product file '" + this.targetProductFilePath + "'.");
                    processMasterGraph(localOutputFolder, masterGraphFile, remoteMachinesGraphHelper.getOutputProductsRelativeFilePath());
                } else {
                    logger.log(Level.FINE, "The target product is not created because its attributes are not specified.");
                }
            } else {
                // an exception occurred on a remote machine
                if (canCreateTargetProduct) {
                    logger.log(Level.FINE, "The target product cannot be created because an exception occurred on a remote machine.");
                } else {
                    logger.log(Level.FINE, "An exception occurred on a remote machine.");
                }
            }
        } else {
            logger.log(Level.FINE, "The output products have not been created in maximum "+this.waitingSecondsTimeout+" seconds on the remote machines.");
        }
    }

    private RemoteMachineGraphExecutorRunnable buildRemoteMachineGraphExecutorRunnable(RemoteMachineCredentials remoteMachineCredentials, RemoteMachinesGraphHelper remoteMachinesGraphHelper,
                                                                                       CountDownLatch sharedCounter) {

        AbstractRemoteMachineExecutor remoteMachineExecutor = buildRemoteMachineExecutor(remoteMachineCredentials, remoteMachinesGraphHelper);
        return new RemoteMachineGraphExecutorRunnable(remoteMachineExecutor, sharedCounter);
    }

    private void processMasterGraph(Path localOutputFolder, Path masterGraphFile, String[] outputProductsRelativeFilePath) throws Exception {
        Graph masterGraph = RemoteMachinesGraphHelper.readGraph(masterGraphFile);

        List<Node> readOperatorNodes = new ArrayList<Node>();
        List<Node> writeOperatorNodes = new ArrayList<Node>();
        for (int i = 0; i < masterGraph.getNodeCount(); i++) {
            Node node = masterGraph.getNode(i);
            if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(WriteOp.class))) {
                RemoteMachinesGraphHelper.configureGraphWriteNode(node);
                writeOperatorNodes.add(node);
            } else if (node.getOperatorName().equalsIgnoreCase(OperatorSpi.getOperatorAlias(ReadOp.class))) {
                RemoteMachinesGraphHelper.configureGraphReadNode(node);
                readOperatorNodes.add(node);
            }
        }
        if (writeOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain the write operator.");
        }
        if (writeOperatorNodes.size() > 1) {
            throw new IllegalStateException("The target graph must contain only one write operator. The actual number is " + writeOperatorNodes.size() + ".");
        }
        if (readOperatorNodes.size() == 0) {
            throw new IllegalStateException("The target graph must contain at least one read operator.");
        }
        if (outputProductsRelativeFilePath.length != readOperatorNodes.size()) {
            throw new IllegalStateException("The output product file count " + outputProductsRelativeFilePath.length + " is not equal with the target graph read operator count " + readOperatorNodes.size() + ".");
        }

        Path localSharedFolderPath = localOutputFolder.getParent();

        for (int i = 0; i < readOperatorNodes.size(); i++) {
            Node readOperatorNode = readOperatorNodes.get(i);
            String normalizedOutputProductRelativePath = CloudExploitationPlatformOp.normalizePath(outputProductsRelativeFilePath[i]);
            Path sourceProductPath = localSharedFolderPath.resolve(normalizedOutputProductRelativePath);
            String sourceProductFilePathOnSharedMachine = sourceProductPath.toString();
            if (Files.exists(sourceProductPath)) {
                DomElement fileParam = readOperatorNode.getConfiguration().getChild("file");
                fileParam.setValue(sourceProductFilePathOnSharedMachine);
            } else {
                throw new IllegalStateException("The remote output product file " + sourceProductFilePathOnSharedMachine + " does not exist.");
            }
        }

        Node writeOperatorNode = writeOperatorNodes.get(0);
        DomElement fileParam = writeOperatorNode.getConfiguration().getChild("file");
        fileParam.setValue(this.targetProductFilePath);
        DomElement formatNameParam = writeOperatorNode.getConfiguration().getChild("formatName");
        formatNameParam.setValue(this.targetProductFormatName);

        GraphProcessor processor = new GraphProcessor();
        processor.executeGraph(masterGraph, new PrintWriterConciseProgressMonitor(System.out));
    }

    public String getTargetProductFilePath() {
        return this.targetProductFilePath;
    }

    public static String normalizePath(String path) {
        if (SystemUtils.IS_OS_WINDOWS) {
            return normalizeWindowsPath(path);
        } else if (SystemUtils.IS_OS_LINUX || SystemUtils.IS_OS_MAC) {
            return normalizeUnixPath(path);
        } else {
            throw new UnsupportedOperationException("Unsupported operating system '" + SystemUtils.OS_NAME + "'.");
        }
    }

    public static boolean mountWindowsLocalDrive(String masterSharedFolderURL, String masterSharedFolderUsername, String masterSharedFolderPassword, String localDrive)
                                                 throws IOException {

        String command = buildWindowsMountSharedDriveCommand(masterSharedFolderURL, masterSharedFolderUsername, masterSharedFolderPassword, localDrive);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeWindowsCommand(command, null, outputConsole);

        boolean sharedDriveMounted = (exitStatus == 0);
        if (sharedDriveMounted) {
            if (logger.isLoggable(Level.FINE)){
                logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully mounted the Windows shared drive '"+localDrive+"'.", command, outputConsole, exitStatus));
            }
        } else {
            logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to mount the Windows shared drive '"+localDrive+"'.", command, outputConsole, exitStatus));
        }

        return sharedDriveMounted;
    }

    public static boolean unmountWindowsLocalDrive(String localDrive) throws IOException {
        String command = buildWindowsUnmountSharedDriveCommand(localDrive);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeWindowsCommand(command, null, outputConsole);

        boolean sharedDriveUnmounted = (exitStatus == 0);
        if (sharedDriveUnmounted) {
            if (logger.isLoggable(Level.FINE)) {
                logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully unmounted the Windows shared drive '"+localDrive+"'.", command, outputConsole, exitStatus));
            }
        } else {
            logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to unmount the Windows shared drive '"+localDrive+"'.", command, outputConsole, exitStatus));
        }

        return sharedDriveUnmounted;
    }

    private static Path buildPath(String pathAsString) throws URISyntaxException {
        int semicolonIndex = pathAsString.indexOf(':');
        if (semicolonIndex > -1) {
            String uriScheme = pathAsString.substring(0, semicolonIndex);
            List<FileSystemProvider> fileSystemProviders = FileSystemProvider.installedProviders();
            for (int i=0; i<fileSystemProviders.size(); i++) {
                FileSystemProvider fileSystemProvider = fileSystemProviders.get(i);
                if (uriScheme.equalsIgnoreCase(fileSystemProvider.getScheme())) {
                    URI uri = new URI(pathAsString);
                    return fileSystemProvider.getPath(uri);
                }
            }
        }
        return Paths.get(pathAsString);
    }

    private static Path checkGraphFileIfExists(ILocalMachineFileSystem localMachineFileSystem, String normalizedMasterSharedFolderURL,
                                               Path localSharedFolder, String graphFilePathToCheck, boolean isMasterGraph) throws URISyntaxException {

        String exceptionMessagePrefix;
        if (isMasterGraph) {
            exceptionMessagePrefix = "The master graph file '";
        } else {
            exceptionMessagePrefix = "The slave graph file '";
        }

        String normalizedGraphFilePath = localMachineFileSystem.normalizeFileSeparator(graphFilePathToCheck);
        if (localMachineFileSystem.pathStartsWith(normalizedGraphFilePath, normalizedMasterSharedFolderURL)) {
            // the graph file must exists into the master shared folder
            String relativePath = normalizedGraphFilePath.substring(normalizedMasterSharedFolderURL.length());
            Path graphFilePath = localSharedFolder.resolve(relativePath);
            if (!Files.exists(graphFilePath)) {
                throw new OperatorException(exceptionMessagePrefix + normalizedGraphFilePath + "' does not exist into the master shared folder.");
            }
            return graphFilePath;
        }
        // the graph file must exists on the local disk
        Path graphFilePath = buildPath(graphFilePathToCheck);
        if (!Files.exists(graphFilePath)) {
            throw new OperatorException(exceptionMessagePrefix + normalizedGraphFilePath + "' does not exist on the local disk.");
        }
        return graphFilePath;
    }

    public static UnixMountLocalFolderResult mountMacLocalFolder(String remoteSharedFolderURL, String remoteUsername, String remotePassword, String localSharedFolderPath)
                                                                   throws IOException {

        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeUnixPath(localSharedFolderPath);

        UnixMountLocalFolderResult localMachineMountFolder = new UnixMountLocalFolderResult();
        boolean localSharedFolderExists;
        if (Files.exists(Paths.get(normalizedLocalSharedFolderPath))) {
            // the local shared folder already exists on the local disk
            localSharedFolderExists = true;
        } else {
            // the local shared folder does not exist on the local disk
            localSharedFolderExists = makeUnixFolder(normalizedLocalSharedFolderPath, null);
            localMachineMountFolder.setSharedFolderCreated(localSharedFolderExists);
        }

        if (localSharedFolderExists) {
            // the changed mode command has been successfully executed on the local shared folder
            String normalizedRemoteSharedFolderURL = CloudExploitationPlatformOp.normalizeUnixPath(remoteSharedFolderURL);

            String command = buildMacMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, remotePassword);
            OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
            int exitStatus = ProcessExecutor.executeUnixCommand(command, null, null, outputConsole);

            command = buildMacMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, "...");

            if (exitStatus == 0) {
                // the local shared folder has been successfully mounted
                if (logger.isLoggable(Level.FINE)) {
                    logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully mount the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
                }

                localMachineMountFolder.setSharedFolderMounted(true);
            } else {
                // failed to mount the local shared folder
                logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to mount the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));

                if (localMachineMountFolder.isSharedFolderCreated()) {
                    // the local shared folder has not been mounted and remote the folder
                    boolean folderDeleted = deleteUnixLocalSharedFolder(normalizedLocalSharedFolderPath, null);
                    localMachineMountFolder.setSharedFolderCreated(!folderDeleted);
                }
            }
        }
        return localMachineMountFolder;
    }

    private static boolean makeUnixFolder(String normalizedLocalSharedFolderPath, String localPassword) throws IOException {
        String command = buildUnixMakeFolderCommand(normalizedLocalSharedFolderPath);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeUnixCommand(command, localPassword, null, outputConsole);

        boolean localSharedFolderCreated = (exitStatus == 0);
        if (localSharedFolderCreated) {
            if (logger.isLoggable(Level.FINE)) {
                logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully created the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
            }
        } else {
            logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to create the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
        }

        return localSharedFolderCreated;
    }

    public static UnixMountLocalFolderResult mountLinuxLocalFolder(String remoteSharedFolderURL, String remoteUsername, String remotePassword,
                                                                   String localSharedFolderPath, String localPassword)
                                                                   throws IOException {

        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeUnixPath(localSharedFolderPath);

        UnixMountLocalFolderResult localMachineMountFolder = new UnixMountLocalFolderResult();
        boolean localSharedFolderExists;
        if (Files.exists(Paths.get(normalizedLocalSharedFolderPath))) {
            // the local shared folder already exists on the local disk
            localSharedFolderExists = true;
        } else {
            // the local shared folder does not exist on the local disk
            localSharedFolderExists = makeUnixFolder(normalizedLocalSharedFolderPath, localPassword);
            localMachineMountFolder.setSharedFolderCreated(localSharedFolderExists);
        }

        if (localSharedFolderExists) {
            String command = buildLinuxChangeModeFolderCommand(normalizedLocalSharedFolderPath);
            OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
            int exitStatus = ProcessExecutor.executeUnixCommand(command, localPassword, null, outputConsole);

            if (exitStatus == 0) {
                // the changed mode command has been successfully executed on the local shared folder
                if (logger.isLoggable(Level.FINE)) {
                    logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully change mode of the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
                }

                String normalizedRemoteSharedFolderURL = CloudExploitationPlatformOp.normalizeUnixPath(remoteSharedFolderURL);

                command = buildLinuxMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, remotePassword);
                outputConsole = new OutputConsoleBuffer();
                exitStatus = ProcessExecutor.executeUnixCommand(command, localPassword, null, outputConsole);

                command = buildLinuxMountSharedFolderCommand(normalizedRemoteSharedFolderURL, normalizedLocalSharedFolderPath, remoteUsername, "...");

                if (exitStatus == 0) {
                    // the local shared folder has been successfully mounted
                    if (logger.isLoggable(Level.FINE)) {
                        logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully mount the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
                    }

                    localMachineMountFolder.setSharedFolderMounted(true);
                } else {
                    // failed to mount the local shared folder
                    logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to mount the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));

                    if (localMachineMountFolder.isSharedFolderCreated()) {
                        // the local shared folder has not been mounted and remote the folder
                        boolean folderDeleted = deleteUnixLocalSharedFolder(normalizedLocalSharedFolderPath, localPassword);
                        localMachineMountFolder.setSharedFolderCreated(!folderDeleted);
                    }
                }
            } else {
                // failed to change mode
                logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to change mode of the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
            }
        }
        return localMachineMountFolder;
    }

    private static boolean unmountUnixLocalSharedFolder(String localSharedFolderPath, String localPassword, UnixMountLocalFolderResult unixMountLocalFolderResult, boolean isLinux)
                                                        throws IOException {

        String normalizedLocalSharedFolderPath = CloudExploitationPlatformOp.normalizeUnixPath(localSharedFolderPath);

        String command;
        if (isLinux) {
            command = buildUnmountUnixSharedFolderCommand(normalizedLocalSharedFolderPath);
        } else {
            command = "diskutil umount force " + normalizedLocalSharedFolderPath;
        }
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeUnixCommand(command, localPassword, null, outputConsole);

        boolean localSharedFolderUnmounted = (exitStatus == 0);
        if (localSharedFolderUnmounted) {
            if (logger.isLoggable(Level.FINE)){
                logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully unmounted the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
            }
        } else {
            logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to unmount the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
        }

        if (unixMountLocalFolderResult.isSharedFolderCreated()) {
            deleteUnixLocalSharedFolder(normalizedLocalSharedFolderPath, localPassword);
        }
        return localSharedFolderUnmounted;
    }

    public static void unmountLinuxLocalFolder(String localSharedFolderPath, String localPassword, UnixMountLocalFolderResult unixMountLocalFolderResult) throws IOException {
        unmountUnixLocalSharedFolder(localSharedFolderPath, localPassword, unixMountLocalFolderResult, true);
    }

    public static void unmountMacLocalFolder(String localSharedFolderPath, UnixMountLocalFolderResult unixMountLocalFolderResult) throws IOException {
        unmountUnixLocalSharedFolder(localSharedFolderPath, null, unixMountLocalFolderResult, false); // 'null' => no password for Mac
    }

    private static boolean deleteUnixLocalSharedFolder(String normalizedLocalSharedFolderPath, String localPassword) throws IOException {
        String command = buildUnixRemoveFolderCommand(normalizedLocalSharedFolderPath);
        OutputConsoleBuffer outputConsole = new OutputConsoleBuffer();
        int exitStatus = ProcessExecutor.executeUnixCommand(command, localPassword, null, outputConsole);

        boolean localSharedFolderDeleted = (exitStatus == 0);
        if (localSharedFolderDeleted) {
            if (logger.isLoggable(Level.FINE)) {
                logger.log(Level.FINE, buildCommandExecutedLogMessage("Successfully deleted the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
            }
        } else {
            logger.log(Level.SEVERE, buildCommandExecutedLogMessage("Failed to delete the local shared folder '"+normalizedLocalSharedFolderPath+"'.", command, outputConsole, exitStatus));
        }

        return localSharedFolderDeleted;
    }

    public static String normalizeWindowsPath(String path) {
        return path.replace('/', '\\');
    }

    public static String normalizeUnixPath(String path) {
        return path.replace('\\', '/');
    }

    public static String buildCommandExecutedLogMessage(String message, String command, OutputConsoleBuffer consoleBuffer, int exitStatus) {
        String newLineAndTab = "\n\t";
        String normalKey = "Normal: ";
        String errorKey = "Error: ";

        String emptySpaces = buildStringWithEmptySpaces(normalKey.length());
        String normalMessages = consoleBuffer.getNormalStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        emptySpaces = buildStringWithEmptySpaces(errorKey.length());
        String errorMessages = consoleBuffer.getErrorStreamMessages().replace(OutputConsoleBuffer.MESSAGE_SEPARATOR, newLineAndTab + emptySpaces);

        StringBuilder logMessage = new StringBuilder();
        logMessage.append(message)
                .append(newLineAndTab)
                .append("Command: ")
                .append(command)
                .append(newLineAndTab)
                .append("Exit status: ")
                .append(exitStatus)
                .append(newLineAndTab)
                .append(normalKey)
                .append(normalMessages)
                .append(newLineAndTab)
                .append(errorKey)
                .append(errorMessages);
        return logMessage.toString();
    }

    public static String buildUnmountUnixSharedFolderCommand(String mountedFolderPath) {
        return "umount " + mountedFolderPath;
    }

    public static String buildUnixRemoveFolderCommand(String folderPath) {
        return "rmdir " + folderPath;
    }

    public static String buildUnixMakeFolderCommand(String folderPath) {
        return "mkdir " + folderPath;
    }

    public static String buildLinuxChangeModeFolderCommand(String folderPath) {
        return "chmod -R 0777 "+ folderPath;
    }

    public static String buildMacMountSharedFolderCommand(String remoteMachineSharedFolderURL, String localFolderPathToMount,
                                                          String remoteMachineUsername, String remoteMachinePassword) {

        StringBuilder command = new StringBuilder();
        command.append("mount -t smbfs")
                .append(" //")
                .append(remoteMachineUsername)
                .append(":")
                .append(remoteMachinePassword)
                .append("@")
                .append(remoteMachineSharedFolderURL.substring(2))
                .append(" ")
                .append(localFolderPathToMount);
        return command.toString();
    }

    public static String buildLinuxMountSharedFolderCommand(String remoteMachineSharedFolderURL, String localFolderPathToMount,
                                                            String remoteMachineUsername, String remoteMachinePassword) {

        StringBuilder command = new StringBuilder();
        command.append("mount.cifs")
                .append(" ")
                .append(remoteMachineSharedFolderURL)
                .append(" ")
                .append(localFolderPathToMount)
                .append(" ")
                .append("-o user=")
                .append(remoteMachineUsername)
                .append(",password=")
                .append(remoteMachinePassword)
                .append(",file_mode=0777,dir_mode=0777,noperm");
        return command.toString();
    }

    public static String buildWindowsMountSharedDriveCommand(String masterSharedFolderURL, String masterSharedFolderUsername,
                                                             String masterSharedFolderPassword, String localDrive) {

        StringBuilder command = new StringBuilder();
        command.append("net use")
                .append(" ")
                .append(localDrive)
                .append(" ")
                .append(CloudExploitationPlatformOp.normalizeWindowsPath(masterSharedFolderURL))
                .append(" ")
                .append(masterSharedFolderPassword)
                .append(" ")
                .append("/user:")
                .append(masterSharedFolderUsername)
                .append(" ")
                .append("/persistent:no");
        return command.toString();
    }

    public static String buildWindowsUnmountSharedDriveCommand(String localDrive) {
        StringBuilder command = new StringBuilder();
        command.append("net use")
                .append(" ")
                .append(localDrive)
                .append(" ")
                .append("/delete /y");
        return command.toString();
    }

    public static RemoteMachineConnectionResult canConnectToRemoteMachine(RemoteMachineCredentials machineCredentials, ITestRemoteMachineConnection callback)
                                                                          throws JSchException, IOException {

        // check if can connect to the remote machine
        callback.testSSHConnection();

        SSHConnection sshConnection = new SSHConnection(machineCredentials.getHostName(), machineCredentials.getPortNumber(), machineCredentials.getUsername(), machineCredentials.getPassword());
        sshConnection.connect();
        try {
            // the remote machine is available
            boolean isRemoteMachineAvailable = true;

            // check if the GPT application is available on the remote machine
            callback.testGPTApplication();

            String gptFilePath;
            if (StringUtils.isBlank(machineCredentials.getGPTFilePath())) {
                gptFilePath = "gpt";
            } else {
                gptFilePath = machineCredentials.getGPTFilePath();
            }
            String command = gptFilePath;
            OutputConsoleBuffer consoleBuffer = new OutputConsoleBuffer();
            int exitStatus = sshConnection.executeWindowsCommand(command, consoleBuffer);
            boolean isGPTApplicationAvailable;
            if (exitStatus == 0) {
                // the GPT application has been successfully tested on the remote machine
                isGPTApplicationAvailable = true;
                if (logger.isLoggable(Level.FINE)) {
                    logger.log(Level.FINE, buildSuccessfullyTestedGPTApplicationLogMessage(machineCredentials.getHostName(), gptFilePath, command, consoleBuffer, exitStatus));
                }
            } else {
                // failed to test the GPT application on the remote machine
                isGPTApplicationAvailable = false;
                logger.log(Level.SEVERE, buildFailedTestedGPTApplicationLogMessage(machineCredentials.getHostName(), gptFilePath, command, consoleBuffer, exitStatus));
            }

            return new RemoteMachineConnectionResult(isRemoteMachineAvailable, isGPTApplicationAvailable);
        } finally {
            sshConnection.disconnect();
        }
    }

    private static String buildSuccessfullyTestedGPTApplicationLogMessage(String remoteMachineHost, String gptFilePath, String command, OutputConsoleBuffer consoleBuffer, int exitStatus) {
        StringBuilder message = new StringBuilder();
        message.append("Successfully tested the GPT application '")
                .append(gptFilePath)
                .append("' on the remote machine '")
                .append(remoteMachineHost)
                .append("'.");
        return CloudExploitationPlatformOp.buildCommandExecutedLogMessage(message.toString(), command, consoleBuffer, exitStatus);
    }

    private static String buildFailedTestedGPTApplicationLogMessage(String remoteMachineHost, String gptFilePath, String command, OutputConsoleBuffer consoleBuffer, int exitStatus) {
        StringBuilder message = new StringBuilder();
        message.append("Failed to test the GPT application '")
                .append(gptFilePath)
                .append("' on the remote machine '")
                .append(remoteMachineHost)
                .append("'.");
        return CloudExploitationPlatformOp.buildCommandExecutedLogMessage(message.toString(), command, consoleBuffer, exitStatus);
    }

    private static String buildStringWithEmptySpaces(int length) {
        StringBuilder result = new StringBuilder(length);
        for (int i=0; i<length; i++) {
            result.append(' ');
        }
        return result.toString();
    }

    public static XppDom buildDom(String xml) {
        XppDomWriter domWriter = new XppDomWriter();
        new HierarchicalStreamCopier().copy(new XppReader(new StringReader(xml), new MXParser()), domWriter);
        return domWriter.getConfiguration();
    }

    private static class RemoteMachineGraphExecutorRunnable implements Runnable {

        private static final Logger logger = Logger.getLogger(RemoteMachineGraphExecutorRunnable.class.getName());

        private final AbstractRemoteMachineExecutor remoteMachineExecutor;
        private final CountDownLatch sharedCounter;

        public RemoteMachineGraphExecutorRunnable(AbstractRemoteMachineExecutor remoteMachineExecutor, CountDownLatch sharedCounter) {
            this.remoteMachineExecutor = remoteMachineExecutor;
            this.sharedCounter = sharedCounter;
        }

        @Override
        public void run() {
            try {
                this.remoteMachineExecutor.execute();
            } catch (Exception exception) {
                this.remoteMachineExecutor.setExceptionOccurredOnRemoteMachine(exception);
                logger.log(Level.SEVERE, this.remoteMachineExecutor.buildFailedLogMessage(), exception);
            } finally {
                this.sharedCounter.countDown();
            }
        }

        public final void stopRunningCommand() throws Exception {
            this.remoteMachineExecutor.stopRunningCommand();
        }
    }

    /**
     * Collocation operator SPI.
     */
    public static class Spi extends OperatorSpi {

        public Spi() {
            super(CloudExploitationPlatformOp.class);
        }
    }
}
